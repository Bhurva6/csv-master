import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go

# Configure the page
st.set_page_config(
    page_title="CSV Data Explorer",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Main title
st.title("üìä CSV Operations")
st.markdown("---")

# Features section - Always visible
st.header("‚ú® Features")

col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    if st.button("üë®‚Äçüíº Create Personas", use_container_width=True):
        st.session_state['feature'] = 'personas'
    st.markdown("""
    Generate detailed customer personas from your data
    """)

with col2:
    if st.button("üìß Verify Emails", use_container_width=True):
        st.session_state['feature'] = 'emails'
    st.markdown("""
    Advanced email validation with legitimacy scoring & Excel export
    """)

with col3:
    if st.button("üìû Verify Phone Numbers", use_container_width=True):
        st.session_state['feature'] = 'phones'
    st.markdown("""
    Advanced phone validation with format checking, region detection & Excel export
    """)

with col4:
    if st.button("üîç Auto-Fill Missing Data", use_container_width=True):
        st.session_state['feature'] = 'autofill'
    st.markdown("""
    Automatically find and fill missing emails & phone numbers
    """)

with col5:
    if st.button("üìà Increase Reach", use_container_width=True):
        st.session_state['feature'] = 'reach'
    st.markdown("""
    Find leads by location and profession using web scraping
    """)

st.markdown("---")

# Sidebar for file upload
st.sidebar.header("Upload Your Data")
uploaded_file = st.sidebar.file_uploader(
    "Choose a CSV file",
    type="csv",
    help="Upload a CSV file to explore and visualize your data"
)

# Check for uploaded file or sample data
if uploaded_file is not None or 'uploaded_file' in st.session_state:
    # Handle both real uploads and sample data
    if uploaded_file is not None:
        file_data = uploaded_file
        filename = uploaded_file.name
    else:
        # Use sample data from session state
        file_data = st.session_state['uploaded_file']
        filename = st.session_state.get('uploaded_filename', 'sample_data.csv')
    
    try:
        # Read the CSV file
        if isinstance(file_data, bytes):
            import io
            df = pd.read_csv(io.BytesIO(file_data))
        else:
            df = pd.read_csv(file_data)
        
        # Store the DataFrame in session state for use in features
        st.session_state['df'] = df
        
        # Data preview
        st.subheader("üîç Data Preview")
        st.dataframe(df.head(100), use_container_width=True)
        
        # Column information
        st.subheader("üìä Column Information")
        col_info = pd.DataFrame({
            'Column': df.columns,
            'Data Type': df.dtypes,
            'Non-Null Count': df.count(),
            'Null Count': df.isnull().sum(),
            'Unique Values': df.nunique()
        })
        st.dataframe(col_info, use_container_width=True)
        
        # Data visualization section
        st.header("üìà Data Visualization")
        
        # Select columns for visualization
        numeric_columns = df.select_dtypes(include=[np.number]).columns.tolist()
        categorical_columns = df.select_dtypes(include=['object']).columns.tolist()
        
        if numeric_columns:
            st.subheader("Numeric Data Analysis")
            
            # Statistical summary
            st.write("**Statistical Summary:**")
            st.dataframe(df[numeric_columns].describe(), use_container_width=True)
            
            # Correlation heatmap
            if len(numeric_columns) > 1:
                st.write("**Correlation Heatmap:**")
                correlation_matrix = df[numeric_columns].corr()
                fig_heatmap = px.imshow(
                    correlation_matrix,
                    text_auto=True,
                    aspect="auto",
                    title="Correlation Matrix"
                )
                st.plotly_chart(fig_heatmap, use_container_width=True)
            
            # Distribution plots
            st.write("**Distribution Plots:**")
            selected_numeric = st.selectbox("Select a numeric column:", numeric_columns)
            if selected_numeric:
                fig_hist = px.histogram(
                    df, 
                    x=selected_numeric, 
                    title=f"Distribution of {selected_numeric}",
                    marginal="box"
                )
                st.plotly_chart(fig_hist, use_container_width=True)
        
        if categorical_columns:
            st.subheader("Categorical Data Analysis")
            selected_categorical = st.selectbox("Select a categorical column:", categorical_columns)
            if selected_categorical:
                # Value counts
                value_counts = df[selected_categorical].value_counts().head(20)
                
                col1, col2 = st.columns(2)
                with col1:
                    # Bar chart
                    fig_bar = px.bar(
                        x=value_counts.index,
                        y=value_counts.values,
                        title=f"Top Values in {selected_categorical}",
                        labels={'x': selected_categorical, 'y': 'Count'}
                    )
                    st.plotly_chart(fig_bar, use_container_width=True)
                
                with col2:
                    # Pie chart
                    fig_pie = px.pie(
                        values=value_counts.values,
                        names=value_counts.index,
                        title=f"Distribution of {selected_categorical}"
                    )
                    st.plotly_chart(fig_pie, use_container_width=True)
        
        # Custom visualization
        if len(numeric_columns) >= 2:
            st.subheader("Custom Scatter Plot")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                x_axis = st.selectbox("X-axis:", numeric_columns, key="x_axis")
            with col2:
                y_axis = st.selectbox("Y-axis:", numeric_columns, key="y_axis", index=1 if len(numeric_columns) > 1 else 0)
            with col3:
                color_by = st.selectbox("Color by:", ["None"] + categorical_columns, key="color_by")
            
            if x_axis and y_axis:
                fig_scatter = px.scatter(
                    df,
                    x=x_axis,
                    y=y_axis,
                    color=color_by if color_by != "None" else None,
                    title=f"{y_axis} vs {x_axis}",
                    hover_data=df.columns[:5].tolist()  # Show first 5 columns on hover
                )
                st.plotly_chart(fig_scatter, use_container_width=True)
        
        # Data filtering
        st.header("üîç Data Filtering")
        st.write("Filter your data based on column values:")
        
        filters = {}
        for col in df.columns:
            if df[col].dtype in ['object']:
                unique_values = df[col].dropna().unique()
                if len(unique_values) <= 20:  # Only show filter for columns with <= 20 unique values
                    selected_values = st.multiselect(
                        f"Filter by {col}:",
                        options=unique_values,
                        key=f"filter_{col}"
                    )
                    if selected_values:
                        filters[col] = selected_values
            elif df[col].dtype in ['int64', 'float64']:
                min_val, max_val = float(df[col].min()), float(df[col].max())
                if min_val != max_val:
                    range_values = st.slider(
                        f"Filter {col} range:",
                        min_value=min_val,
                        max_value=max_val,
                        value=(min_val, max_val),
                        key=f"range_{col}"
                    )
                    if range_values != (min_val, max_val):
                        filters[col] = range_values
        
        # Apply filters
        filtered_df = df.copy()
        for col, values in filters.items():
            if df[col].dtype in ['object']:
                filtered_df = filtered_df[filtered_df[col].isin(values)]
            else:
                filtered_df = filtered_df[
                    (filtered_df[col] >= values[0]) & 
                    (filtered_df[col] <= values[1])
                ]
        
        if len(filters) > 0:
            st.write(f"**Filtered Data ({len(filtered_df)} rows)**")
            st.dataframe(filtered_df, use_container_width=True)
            
            # Download filtered data
            csv = filtered_df.to_csv(index=False)
            st.download_button(
                label="Download filtered data as CSV",
                data=csv,
                file_name="filtered_data.csv",
                mime="text/csv"
            )
    
    except Exception as e:
        st.error(f"Error reading the CSV file: {str(e)}")
        st.info("Please make sure your file is a valid CSV format.")

else:
    # Landing page when no file is uploaded
    st.info("üëà Please upload a CSV file using the sidebar to get started!")
    
    # Sample data section
    st.header("üéØ Try with Sample Data")
    
    if st.button("Generate Sample Data"):
        # Create sample data
        np.random.seed(42)
        sample_data = pd.DataFrame({
            'Name': [f'Person_{i}' for i in range(100)],
            'Age': np.random.randint(18, 65, 100),
            'Salary': np.random.normal(50000, 15000, 100),
            'Department': np.random.choice(['Engineering', 'Sales', 'Marketing', 'HR'], 100),
            'Experience': np.random.randint(0, 20, 100),
            'Performance_Score': np.random.uniform(1, 5, 100),
            'Gender': np.random.choice(['Male', 'Female', 'Non-binary', 'Prefer not to say'], 100),
            'City': np.random.choice(['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio', 'San Diego', 'Dallas', 'San Jose'], 100),
            'Email': [
                f"{f'Person_{i}'.lower().replace(' ', '.')}.{i}@example.com" if i % 10 != 0 else 
                f"user{i}@gmail.com" if i % 10 == 1 else
                f"contact{i}@yahoo.com" if i % 10 == 2 else
                f"info{i}@company.com" if i % 10 == 3 else
                f"test{i}@temp-mail.org" if i % 10 == 4 else
                f"person{i}@outlook.com" if i % 10 == 5 else
                f"employee{i}@business.net" if i % 10 == 6 else
                f"client{i}@mailinator.com" if i % 10 == 7 else
                "" if i % 10 == 8 else  # Empty email for testing
                f"invalid-email{i}"  # Invalid format for testing
                for i in range(100)
            ],
            'Phone': [
                f"+1-{np.random.randint(200,999)}-{np.random.randint(100,999)}-{np.random.randint(1000,9999)}" if i % 15 != 0 else
                f"({np.random.randint(200,999)}) {np.random.randint(100,999)}-{np.random.randint(1000,9999)}" if i % 15 == 1 else
                f"+44 {np.random.randint(20,99)} {np.random.randint(1000,9999)} {np.random.randint(1000,9999)}" if i % 15 == 2 else
                f"+91 {np.random.randint(7000000000,9999999999)}" if i % 15 == 3 else
                f"{np.random.randint(200,999)}-{np.random.randint(100,999)}-{np.random.randint(1000,9999)}" if i % 15 == 4 else
                f"+1-{np.random.randint(200,999)}-{np.random.randint(100,999)}-{np.random.randint(1000,9999)}, +44 {np.random.randint(20,99)} {np.random.randint(1000,9999)} {np.random.randint(1000,9999)}" if i % 15 == 5 else  # Multiple phones
                f"({np.random.randint(200,999)}) {np.random.randint(100,999)}-{np.random.randint(1000,9999)}; +91 {np.random.randint(7000000000,9999999999)}" if i % 15 == 6 else  # Multiple phones
                f"invalid-phone-{i}" if i % 15 == 7 else  # Invalid format
                f"123" if i % 15 == 8 else  # Too short
                "" if i % 15 == 9 else  # Empty
                f"+{np.random.randint(100,999)} {np.random.randint(100000,999999)}"  # International format
                for i in range(100)
            ]
        })
        
        st.success("Sample data generated!")
        st.dataframe(sample_data.head(10), use_container_width=True)
        
        # Store sample data in session state for immediate use
        st.session_state['sample_data'] = sample_data
        
        # Download sample data
        csv_sample = sample_data.to_csv(index=False)
        st.download_button(
            label="Download sample data",
            data=csv_sample,
            file_name="sample_data.csv",
            mime="text/csv"
        )
        
        # Button to use sample data immediately
        if st.button("Use This Sample Data Now"):
            # Convert to CSV bytes and simulate upload
            csv_bytes = sample_data.to_csv(index=False).encode()
            st.session_state['uploaded_file'] = csv_bytes
            st.session_state['uploaded_filename'] = 'sample_data.csv'
            st.rerun()

# Feature implementation - Always available when feature is selected
if 'feature' in st.session_state:
    st.markdown("---")

    if st.session_state['feature'] == 'personas':
        st.header("üë®‚Äçüíº Create Personas")

        # Persona creation logic
        if 'df' in st.session_state:
            try:
                # Use the DataFrame from session state
                df = st.session_state['df']

                # Check for relevant columns - expanded detection
                name_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['name', 'full_name', 'first_name', 'last_name', 'customer_name', 'person_name', 'user_name'])]
                age_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['age', 'age_years', 'person_age', 'user_age', 'years_old'])]
                gender_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['gender', 'sex', 'male', 'female', 'person_gender', 'user_gender'])]
                location_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['city', 'state', 'country', 'location', 'address', 'region', 'province', 'town', 'place'])]

                if name_cols or age_cols or gender_cols or location_cols:
                    found_cols = []
                    if name_cols:
                        found_cols.append(f"Name: {', '.join(name_cols)}")
                    if age_cols:
                        found_cols.append(f"Age: {', '.join(age_cols)}")
                    if gender_cols:
                        found_cols.append(f"Gender: {', '.join(gender_cols)}")
                    if location_cols:
                        found_cols.append(f"Location: {', '.join(location_cols)}")
                    
                    st.success(f"Found relevant columns for persona creation: {', '.join(found_cols)}")

                    # Allow user to select number of personas
                    max_personas = min(10, len(df))  # Limit to 10 or available rows
                    num_personas = st.slider("Number of personas to generate:", min_value=1, max_value=max_personas, value=min(5, max_personas))

                    # Generate personas from random sample
                    if len(df) > num_personas:
                        # Randomly sample rows for diversity
                        sample_indices = np.random.choice(len(df), size=num_personas, replace=False)
                    else:
                        sample_indices = range(len(df))

                    # Generate personas
                    personas = []
                    for i, idx in enumerate(sample_indices):
                        persona = {
                            'Name': f"Persona {i+1}",
                            'Age': "Unknown",
                            'Gender': "Unknown", 
                            'Location': "Unknown"
                        }
                        
                        if name_cols:
                            persona['Name'] = df[name_cols[0]].iloc[idx] if pd.notna(df[name_cols[0]].iloc[idx]) else f"Persona {i+1}"
                        
                        if age_cols:
                            persona['Age'] = df[age_cols[0]].iloc[idx] if pd.notna(df[age_cols[0]].iloc[idx]) else "Unknown"
                        
                        if gender_cols:
                            persona['Gender'] = df[gender_cols[0]].iloc[idx] if pd.notna(df[gender_cols[0]].iloc[idx]) else "Unknown"
                        
                        if location_cols:
                            persona['Location'] = df[location_cols[0]].iloc[idx] if pd.notna(df[location_cols[0]].iloc[idx]) else "Unknown"

                        personas.append(persona)

                    # Display personas
                    for i, persona in enumerate(personas):
                        with st.expander(f"**{persona['Name']}**"):
                            col1, col2 = st.columns(2)
                            with col1:
                                st.write(f"**Age:** {persona['Age']}")
                                st.write(f"**Gender:** {persona['Gender']}")
                            with col2:
                                st.write(f"**Location:** {persona['Location']}")
                                st.write("**Characteristics:** Based on data analysis")

                    # Download personas
                    persona_df = pd.DataFrame(personas)
                    csv_personas = persona_df.to_csv(index=False)
                    st.download_button(
                        label="Download Personas as CSV",
                        data=csv_personas,
                        file_name="personas.csv",
                        mime="text/csv"
                    )
                else:
                    st.warning("No relevant columns found for persona creation. Please ensure your CSV has columns containing keywords like 'name', 'age', 'gender', 'sex', 'city', 'state', 'country', or 'location'.")
                    st.info(f"Available columns in your CSV: {', '.join(df.columns.tolist())}")
                    st.info("If your columns have different names, you may need to rename them or contact support.")

            except Exception as e:
                st.error(f"Error processing data for personas: {str(e)}")
        else:
            st.info("Please upload a CSV file first to create personas.")

    elif st.session_state['feature'] == 'emails':
        st.header("üìß Verify Emails")

        # Email verification logic - works with uploaded CSV or sample data
        if 'df' in st.session_state:
            try:
                # Use the DataFrame from session state
                df = st.session_state['df']

                # Find email columns
                email_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['email', 'mail', 'e-mail', 'email_address'])]

                if email_cols:
                    st.success(f"Found email column(s): {', '.join(email_cols)}")

                    # Select which email column to verify
                    selected_email_col = st.selectbox("Select email column to verify:", email_cols)

                    if st.button("Verify Emails in CSV"):
                        with st.spinner("Verifying emails..."):
                            import re

                            # Import dns.resolver for MX record checking
                            import dns.resolver

                            # Enhanced email validation
                            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

                            # Common disposable/temporary email domains
                            disposable_domains = [
                                '10minutemail.com', 'guerrillamail.com', 'mailinator.com',
                                'temp-mail.org', 'throwaway.email', 'yopmail.com',
                                'maildrop.cc', 'tempail.com', 'dispostable.com'
                            ]

                            # Function to check if domain has valid MX records
                            def has_valid_mx_record(domain):
                                try:
                                    mx_records = dns.resolver.resolve(domain, 'MX')
                                    return len(mx_records) > 0
                                except:
                                    return False

                            results = []
                            for idx, email_data in enumerate(df[selected_email_col]):
                                if pd.isna(email_data) or str(email_data).strip() == '':
                                    results.append({
                                        'Row': idx + 1,
                                        'Original Data': email_data if pd.notna(email_data) else '',
                                        'Email': '',
                                        'Status': 'Empty',
                                        'Notes': 'Missing email address'
                                    })
                                    continue

                                # Handle multiple emails in a single cell
                                email_string = str(email_data).strip()
                                
                                # Split by common delimiters: comma, semicolon, newline, pipe, slash
                                emails_in_cell = re.split(r'[;,|\n/]+', email_string)
                                emails_in_cell = [e.strip() for e in emails_in_cell if e.strip()]

                                if not emails_in_cell:
                                    results.append({
                                        'Row': idx + 1,
                                        'Original Data': email_string,
                                        'Email': '',
                                        'Status': 'Empty',
                                        'Notes': 'No emails found after parsing'
                                    })
                                    continue

                                # Process each email in the cell
                                for email_idx, email in enumerate(emails_in_cell):
                                    email = email.lower()
                                    is_valid_format = bool(re.match(email_pattern, email))

                                if is_valid_format:
                                    domain = email.split('@')[1]
                                    is_disposable = domain in disposable_domains
                                    is_deliverable = not any(x in email for x in ['test', 'example', 'invalid', 'fake'])
                                    has_mx = has_valid_mx_record(domain)

                                    if is_deliverable and not is_disposable and has_mx:
                                        status = 'Valid (Deliverable)'
                                        notes = f'Valid format, {domain} domain with MX records'
                                    elif is_disposable:
                                        status = 'Invalid (Disposable)'
                                        notes = f'Disposable email domain: {domain}'
                                    elif not has_mx:
                                        status = 'Invalid (Unreachable)'
                                        notes = f'Domain {domain} has no valid MX records'
                                    else:
                                        status = 'Invalid (Undeliverable)'
                                        notes = f'Potentially undeliverable: {domain}'
                                else:
                                    status = 'Invalid (Format)'
                                    notes = 'Invalid email format'

                                results.append({
                                    'Row': idx + 1,
                                    'Original Data': email_string if email_idx == 0 else '',  # Show original data only for first email
                                    'Email': email,
                                    'Status': status,
                                    'Notes': f'{notes} (Email {email_idx + 1} of {len(emails_in_cell)})' if len(emails_in_cell) > 1 else notes
                                })

                            results_df = pd.DataFrame(results)

                            # Summary metrics
                            st.subheader("üìä Email Verification Summary")
                            
                            total_emails = len(results)
                            valid_deliverable = sum(1 for r in results if r['Status'] == 'Valid (Deliverable)')
                            invalid_emails = sum(1 for r in results if r['Status'].startswith('Invalid'))
                            empty_emails = sum(1 for r in results if r['Status'] == 'Empty')

                            col1, col2, col3, col4 = st.columns(4)
                            with col1:
                                st.metric("Total Emails", total_emails)
                            with col2:
                                st.metric("Valid (Deliverable)", valid_deliverable)
                            with col3:
                                st.metric("Invalid Emails", invalid_emails)
                            with col4:
                                st.metric("Empty Emails", empty_emails)

                            # Success rate
                            if total_emails > 0:
                                success_rate = (valid_deliverable / total_emails) * 100
                                st.success(f"‚úÖ **{success_rate:.1f}%** of emails are valid and deliverable!")

                            # Visual representation
                            status_counts = results_df['Status'].value_counts()
                            fig_pie = px.pie(
                                values=status_counts.values,
                                names=status_counts.index,
                                title="Email Verification Status Distribution",
                                color_discrete_sequence=['#00ff00', '#ff0000', '#ffff00', '#ff9800']
                            )
                            st.plotly_chart(fig_pie, use_container_width=True)

                            # Show results table
                            st.subheader("üìã Detailed Results")
                            st.dataframe(results_df, use_container_width=True)

                            # Create Excel file for download
                            from io import BytesIO
                            import openpyxl
                            from openpyxl.styles import PatternFill, Font

                            wb = openpyxl.Workbook()
                            ws = wb.active
                            ws.title = "Email Verification Results"

                            # Add summary at the top
                            ws['A1'] = "Email Verification Summary"
                            ws['A1'].font = Font(bold=True, size=14)
                            
                            ws['A3'] = "Total Emails:"
                            ws['B3'] = total_emails
                            ws['A4'] = "Valid (Deliverable):"
                            ws['B4'] = valid_deliverable
                            ws['A5'] = "Invalid Emails:"
                            ws['B5'] = invalid_emails
                            ws['A6'] = "Empty Emails:"
                            ws['B6'] = empty_emails
                            ws['A7'] = f"Success Rate: {success_rate:.1f}%" if total_emails > 0 else "Success Rate: N/A"

                            # Add detailed results starting from row 10
                            start_row = 10
                            headers = list(results_df.columns)
                            for col_num, header in enumerate(headers, 1):
                                cell = ws.cell(row=start_row, column=col_num, value=header)
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")

                            # Add data with conditional formatting
                            for row_num, row_data in enumerate(results_df.values, start_row + 1):
                                for col_num, value in enumerate(row_data, 1):
                                    cell = ws.cell(row=row_num, column=col_num, value=str(value))

                                    # Color coding based on status
                                    if col_num == 3:  # Status column
                                        if 'Valid' in str(value):
                                            cell.fill = PatternFill(start_color="C8E6C9", end_color="C8E6C9", fill_type="solid")
                                        elif 'Invalid' in str(value):
                                            cell.fill = PatternFill(start_color="FFCDD2", end_color="FFCDD2", fill_type="solid")
                                        elif 'Empty' in str(value):
                                            cell.fill = PatternFill(start_color="FFF9C4", end_color="FFF9C4", fill_type="solid")

                            # Auto-adjust column widths
                            for column in ws.columns:
                                max_length = 0
                                column_letter = column[0].column_letter
                                for cell in column:
                                    try:
                                        if len(str(cell.value)) > max_length:
                                            max_length = len(str(cell.value))
                                    except:
                                        pass
                                adjusted_width = min(max_length + 2, 50)
                                ws.column_dimensions[column_letter].width = adjusted_width

                            # Save to BytesIO
                            excel_buffer = BytesIO()
                            wb.save(excel_buffer)
                            excel_buffer.seek(0)

                            # Download button
                            st.download_button(
                                label="üì• Download Verification Results (Excel)",
                                data=excel_buffer,
                                file_name="email_verification_results.xlsx",
                                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                            )

                else:
                    st.warning("No email columns found in your CSV. Please ensure your file has columns containing 'email', 'mail', 'e-mail', or 'email_address' in the name.")
                    st.info(f"Available columns in your CSV: {', '.join(df.columns.tolist())}")
                    st.info("If your email column has a different name, you may need to rename it or contact support.")

            except Exception as e:
                st.error(f"Error processing CSV for email verification: {str(e)}")
        else:
            st.info("Please upload a CSV file first to verify emails.")

    elif st.session_state['feature'] == 'phones':
        st.header("üìû Verify Phone Numbers")

        # Phone verification logic - works with uploaded CSV or sample data
        if 'df' in st.session_state:
            try:
                # Use the DataFrame from session state
                df = st.session_state['df']

                # Find phone columns
                phone_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['phone', 'mobile', 'tel', 'contact', 'cell', 'telephone', 'number'])]

                if phone_cols:
                    st.success(f"Found phone column(s): {', '.join(phone_cols)}")

                    # Select which phone column to verify
                    selected_phone_col = st.selectbox("Select phone column to verify:", phone_cols)

                    if st.button("Verify Phone Numbers in CSV"):
                        with st.spinner("Verifying phone numbers..."):
                            import re

                            results = []
                            for idx, phone_data in enumerate(df[selected_phone_col]):
                                if pd.isna(phone_data) or str(phone_data).strip() == '':
                                    results.append({
                                        'Row': idx + 1,
                                        'Original Data': phone_data if pd.notna(phone_data) else '',
                                        'Phone Number': '',
                                        'Status': 'Empty',
                                        'Notes': 'Missing phone number'
                                    })
                                    continue

                                # Handle multiple phone numbers in a single cell
                                phone_string = str(phone_data).strip()
                                
                                # Split by common delimiters: comma, semicolon, newline, pipe, slash
                                phones_in_cell = re.split(r'[;,|\n/]+', phone_string)
                                phones_in_cell = [p.strip() for p in phones_in_cell if p.strip()]

                                if not phones_in_cell:
                                    results.append({
                                        'Row': idx + 1,
                                        'Original Data': phone_string,
                                        'Phone Number': '',
                                        'Status': 'Empty',
                                        'Notes': 'No phone numbers found after parsing'
                                    })
                                    continue

                                # Process each phone number in the cell
                                for phone_idx, phone in enumerate(phones_in_cell):
                                    # Remove all non-digit characters except + for international codes
                                    clean_phone = re.sub(r'[^\d+]', '', phone)

                                    # Basic validation patterns
                                    us_pattern = r'^\+?1?\d{10}$'
                                    international_pattern = r'^\+\d{1,4}\d{6,14}$'

                                    is_us_format = bool(re.match(us_pattern, clean_phone))
                                    is_international = bool(re.match(international_pattern, clean_phone))

                                    # Determine country/region and phone type
                                    if clean_phone.startswith('+1') or (len(clean_phone) == 10 and not clean_phone.startswith('+')):
                                        region = "US/Canada"
                                        # US/Canada: Landline prefixes typically don't start with 1
                                        is_landline = not (clean_phone[-10] in '2345')
                                    elif clean_phone.startswith('+44'):
                                        region = "UK"
                                        # UK: Landline numbers typically start with 01 or 02
                                        is_landline = clean_phone[3:5] in ['01', '02']
                                    elif clean_phone.startswith('+91'):
                                        region = "India"
                                        # India: Landline numbers are typically 8 digits and start with area codes
                                        is_landline = len(clean_phone[3:]) <= 8
                                    elif clean_phone.startswith('+61'):
                                        region = "Australia"
                                        # Australian landlines start with 02-08
                                        is_landline = clean_phone[3:4] in ['2', '3', '7', '8']
                                    elif clean_phone.startswith('+86'):
                                        region = "China"
                                        is_landline = len(clean_phone[3:]) < 11
                                    elif clean_phone.startswith('+81'):
                                        region = "Japan"
                                        is_landline = not clean_phone[3] in ['7', '8', '9']
                                    elif clean_phone.startswith('+49'):
                                        region = "Germany"
                                        is_landline = not clean_phone[3] in ['1', '5']
                                    elif clean_phone.startswith('+33'):
                                        region = "France"
                                        is_landline = clean_phone[3] == '1'
                                    elif clean_phone.startswith('+'):
                                        region = "International"
                                        is_landline = False  # Default to mobile for unknown international
                                    else:
                                        region = "Unknown"
                                        is_landline = False

                                    # Check if number is likely to be WhatsApp enabled
                                    # Most mobile numbers can use WhatsApp, so we'll assume mobile numbers are WhatsApp-enabled
                                    is_whatsapp = is_valid and not is_landline

                                    is_valid = is_us_format or is_international

                                    results.append({
                                        'Row': idx + 1,
                                        'Original Data': phone_string if phone_idx == 0 else '',
                                        'Phone Number': phone,
                                        'Cleaned': clean_phone,
                                        'Format Valid': '‚úÖ Valid' if is_valid else '‚ùå Invalid',
                                        'Region': region,
                                        'Type': 'Landline' if is_landline else 'Mobile',
                                        'WhatsApp': '‚úÖ Yes' if is_whatsapp else '‚ùå No',
                                        'Status': 'Valid' if is_valid else 'Invalid',
                                        'Notes': f'Phone {phone_idx + 1} of {len(phones_in_cell)} in cell' if len(phones_in_cell) > 1 else ''
                                    })

                            results_df = pd.DataFrame(results)

                            # Summary metrics
                            st.subheader("üìä Phone Verification Summary")
                            
                            total_phones = len(results)
                            valid_phones = sum(1 for r in results if r['Status'] == 'Valid')
                            invalid_phones = sum(1 for r in results if r['Status'] == 'Invalid')
                            empty_entries = sum(1 for r in results if r['Status'] == 'Empty')

                            # Add WhatsApp and phone type counts
                            whatsapp_numbers = sum(1 for r in results if r['WhatsApp'] == '‚úÖ Yes')
                            landline_numbers = sum(1 for r in results if r['Status'] == 'Valid' and r['Type'] == 'Landline')
                            mobile_numbers = sum(1 for r in results if r['Status'] == 'Valid' and r['Type'] == 'Mobile')

                            col1, col2 = st.columns(2)
                            with col1:
                                st.metric("Total Phone Numbers", total_phones)
                                st.metric("Valid Numbers", valid_phones)
                                st.metric("Invalid Numbers", invalid_phones)
                            with col2:
                                st.metric("WhatsApp Enabled", whatsapp_numbers)
                                st.metric("Mobile Numbers", mobile_numbers)
                                st.metric("Landline Numbers", landline_numbers)

                            # Add separate sections for Mobile and Landline numbers
                            if mobile_numbers > 0:
                                st.subheader("üì± Mobile Numbers")
                                mobile_df = results_df[results_df['Type'] == 'Mobile']
                                st.dataframe(mobile_df, use_container_width=True)

                            if landline_numbers > 0:
                                st.subheader("‚òéÔ∏è Landline Numbers")
                                landline_df = results_df[results_df['Type'] == 'Landline']
                                st.dataframe(landline_df, use_container_width=True)

                            # Success rate
                            if total_phones > 0:
                                success_rate = (valid_phones / total_phones) * 100
                                st.success(f"‚úÖ **{success_rate:.1f}%** of phone numbers are valid!")

                            # Visual representation
                            status_counts = results_df['Status'].value_counts()
                            fig_pie = px.pie(
                                values=status_counts.values,
                                names=status_counts.index,
                                title="Phone Verification Status Distribution",
                                color_discrete_sequence=['#00ff00', '#ff0000', '#ffff00', '#ff9800']
                            )
                            st.plotly_chart(fig_pie, use_container_width=True)

                            # Show results table
                            st.subheader("üìã Detailed Results")
                            st.dataframe(results_df, use_container_width=True)

                            # Create Excel file for download
                            from io import BytesIO
                            import openpyxl
                            from openpyxl.styles import PatternFill, Font

                            wb = openpyxl.Workbook()
                            ws = wb.active
                            ws.title = "Phone Verification Results"

                            # Add summary at the top
                            ws['A1'] = "Phone Verification Summary"
                            ws['A1'].font = Font(bold=True, size=14)
                            
                            ws['A3'] = "Total Phone Numbers:"
                            ws['B3'] = total_phones
                            ws['A4'] = "Valid Numbers:"
                            ws['B4'] = valid_phones
                            ws['A5'] = "Invalid Numbers:"
                            ws['B5'] = invalid_phones
                            ws['A6'] = "Empty Entries:"
                            ws['B6'] = empty_entries
                            ws['A7'] = f"Success Rate: {success_rate:.1f}%" if total_phones > 0 else "Success Rate: N/A"
                            ws['A8'] = "WhatsApp Enabled:"
                            ws['B8'] = whatsapp_numbers
                            ws['A9'] = "Mobile Numbers:"
                            ws['B9'] = mobile_numbers
                            ws['A10'] = "Landline Numbers:"
                            ws['B10'] = landline_numbers

                            # Add detailed results starting from row 10
                            start_row = 10
                            headers = list(results_df.columns)
                            for col_num, header in enumerate(headers, 1):
                                cell = ws.cell(row=start_row, column=col_num, value=header)
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")

                            # Add data with conditional formatting
                            for row_num, row_data in enumerate(results_df.values, start_row + 1):
                                for col_num, value in enumerate(row_data, 1):
                                    cell = ws.cell(row=row_num, column=col_num, value=str(value))

                                    # Color coding based on status
                                    if col_num == 6:  # Status column
                                        if 'Valid' in str(value):
                                            cell.fill = PatternFill(start_color="C8E6C9", end_color="C8E6C9", fill_type="solid")
                                        elif 'Invalid' in str(value):
                                            cell.fill = PatternFill(start_color="FFCDD2", end_color="FFCDD2", fill_type="solid")
                                        elif 'Empty' in str(value):
                                            cell.fill = PatternFill(start_color="FFF9C4", end_color="FFF9C4", fill_type="solid")

                            # Auto-adjust column widths
                            for column in ws.columns:
                                max_length = 0
                                column_letter = column[0].column_letter
                                for cell in column:
                                    try:
                                        if len(str(cell.value)) > max_length:
                                            max_length = len(str(cell.value))
                                    except:
                                        pass
                                adjusted_width = min(max_length + 2, 50)
                                ws.column_dimensions[column_letter].width = adjusted_width

                            # Save to BytesIO
                            excel_buffer = BytesIO()
                            wb.save(excel_buffer)
                            excel_buffer.seek(0)

                            # Download button
                            st.download_button(
                                label="üì• Download Verification Results (Excel)",
                                data=excel_buffer,
                                file_name="phone_verification_results.xlsx",
                                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                            )

                else:
                    st.warning("No phone columns found in your CSV. Please ensure your file has columns containing 'phone', 'mobile', 'tel', 'contact', 'cell', 'telephone', or 'number' in the name.")
                    st.info(f"Available columns in your CSV: {', '.join(df.columns.tolist())}")
                    st.info("If your phone column has a different name, you may need to rename it or contact support.")

            except Exception as e:
                st.error(f"Error processing CSV for phone verification: {str(e)}")
        else:
            st.info("Please upload a CSV file first to verify phone numbers.")
    
    elif st.session_state['feature'] == 'autofill':
        st.header("üîç Auto-Fill Missing Data")
        st.info("This feature will search and fill missing or invalid emails and phone numbers using real APIs.")

        if 'df' in st.session_state:
            try:
                df = st.session_state['df']

                # Find relevant columns
                name_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['name', 'full_name', 'first_name', 'last_name', 'customer_name', 'person_name'])]
                email_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['email', 'mail', 'e-mail'])]
                phone_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['phone', 'mobile', 'tel', 'contact'])]
                company_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['company', 'organization', 'business', 'employer'])]

                if name_cols or email_cols or phone_cols:
                    st.success(f"Found columns for auto-fill analysis")
                    
                    # API Configuration Section
                    st.subheader("üîë API Configuration")
                    
                    # API selection
                    api_options = {
                        "Demo Mode (Free)": "demo",
                        "Google Custom Search API": "google",
                        "Hunter.io API": "hunter",
                        "Clearbit API": "clearbit",
                        "ZoomInfo API": "zoominfo"
                    }
                    
                    selected_api = st.selectbox(
                        "Choose API Service:",
                        list(api_options.keys()),
                        help="Select the API service to use for finding contact information"
                    )
                    
                    api_choice = api_options[selected_api]
                    
                    # API Key inputs based on selection
                    api_keys = {}
                    
                    if api_choice == "google":
                        col1, col2 = st.columns(2)
                        with col1:
                            api_keys['google_api_key'] = st.text_input("Google Custom Search API Key:", type="password")
                        with col2:
                            api_keys['google_cx'] = st.text_input("Custom Search Engine ID:")
                        st.info("üí° Get your API key from: https://console.developers.google.com/")
                        
                    elif api_choice == "hunter":
                        api_keys['hunter_api_key'] = st.text_input("Hunter.io API Key:", type="password")
                        st.info("üí° Get your API key from: https://hunter.io/api-keys")
                        
                    elif api_choice == "clearbit":
                        api_keys['clearbit_api_key'] = st.text_input("Clearbit API Key:", type="password")
                        st.info("üí° Get your API key from: https://dashboard.clearbit.com/")
                        
                    elif api_choice == "zoominfo":
                        api_keys['zoominfo_username'] = st.text_input("ZoomInfo Username:")
                        api_keys['zoominfo_password'] = st.text_input("ZoomInfo Password:", type="password")
                        st.info("üí° Get credentials from: https://www.zoominfo.com/")
                    
                    # Configuration
                    st.subheader("‚öôÔ∏è Configuration")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        selected_name_col = st.selectbox("Name Column:", ["None"] + name_cols) if name_cols else "None"
                        selected_email_col = st.selectbox("Email Column:", ["None"] + email_cols) if email_cols else "None"
                    
                    with col2:
                        selected_phone_col = st.selectbox("Phone Column:", ["None"] + phone_cols) if phone_cols else "None"
                        selected_company_col = st.selectbox("Company Column (optional):", ["None"] + company_cols) if company_cols else "None"
                    
                    # Rate limiting and cost control
                    max_requests = st.slider("Max API Requests per Minute:", min_value=1, max_value=60, value=10)
                    st.warning(f"‚ö†Ô∏è This will make up to {len(df)} API calls. Estimated cost: ${len(df) * 0.005:.2f} (Google) or {len(df) * 0.01:.2f} credits (Hunter.io)")

                    if st.button("üöÄ Start Auto-Fill Process", type="primary"):
                        if api_choice != "demo" and not all(api_keys.values()):
                            st.error("Please provide all required API keys for the selected service.")
                            st.stop()
                        
                        with st.spinner("Searching and filling missing data..."):
                            import time
                            import requests
                            from urllib.parse import quote

                            # API Functions
                            def search_google(name, company=None, api_key=None, cx=None):
                                """Search Google Custom Search API"""
                                if not api_key or not cx:
                                    return None
                                
                                try:
                                    query = f"{name}"
                                    if company and company != "Unknown":
                                        query += f" {company}"
                                    query += " email phone contact"
                                    
                                    url = f"https://www.googleapis.com/customsearch/v1?key={api_key}&cx={cx}&q={quote(query)}&num=5"
                                    response = requests.get(url, timeout=10)
                                    
                                    if response.status_code == 200:
                                        data = response.json()
                                        email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
                                        phone_pattern = r'\+?1?\d{10,15}'
                                        
                                        emails = []
                                        phones = []
                                        
                                        for item in data.get('items', [])[:3]:
                                            snippet = item.get('snippet', '')
                                            title = item.get('title', '')
                                            content = snippet + " " + title
                                            
                                            emails.extend(re.findall(email_pattern, content))
                                            phones.extend(re.findall(phone_pattern, content))
                                        
                                        if emails or phones:
                                            return {
                                                'email': emails[0] if emails else None,
                                                'phone': phones[0] if phones else None,
                                                'source': 'Google Custom Search',
                                                'confidence': 'Medium',
                                                'url': data.get('items', [{}])[0].get('link', '') if data.get('items') else ''
                                            }
                                except Exception as e:
                                    st.warning(f"Google API error: {str(e)}")
                                
                                return None

                            def search_hunter(name, company=None, api_key=None):
                                """Search Hunter.io API"""
                                if not api_key:
                                    return None
                                
                                try:
                                    # Try domain search first if company is available
                                    if company and company != "Unknown":
                                        domain_url = f"https://api.hunter.io/v2/domain-search?domain={quote(company)}&api_key={api_key}"
                                        domain_response = requests.get(domain_url, timeout=10)
                                        
                                        if domain_response.status_code == 200:
                                            domain_data = domain_response.json()
                                            emails = domain_data.get('data', {}).get('emails', [])
                                            if emails:
                                                # Find email that matches name
                                                name_parts = str(name).lower().split()
                                                for email_data in emails[:5]:
                                                    email = email_data.get('value', '')
                                                    if name_parts and name_parts[0] in email.lower():
                                                        return {
                                                            'email': email,
                                                            'phone': None,
                                                            'source': 'Hunter.io Domain Search',
                                                            'confidence': 'High',
                                                            'url': f"https://hunter.io/search/{company}"
                                                        }
                                    
                                    # Fallback to email finder
                                    if '@' not in str(name):
                                        finder_url = f"https://api.hunter.io/v2/email-finder?full_name={quote(name)}&api_key={api_key}"
                                        if company and company != "Unknown":
                                            finder_url += f"&company={quote(company)}"
                                        
                                        finder_response = requests.get(finder_url, timeout=10)
                                        
                                        if finder_response.status_code == 200:
                                            finder_data = finder_response.json()
                                            email = finder_data.get('data', {}).get('email')
                                            if email:
                                                return {
                                                    'email': email,
                                                    'phone': None,
                                                    'source': 'Hunter.io Email Finder',
                                                    'confidence': 'High',
                                                    'url': f"https://hunter.io/verify/{email}"
                                                }
                                                
                                except Exception as e:
                                    st.warning(f"Hunter.io API error: {str(e)}")
                                
                                return None

                            def search_clearbit(name, company=None, api_key=None):
                                """Search Clearbit API"""
                                if not api_key:
                                    return None
                                
                                try:
                                    headers = {'Authorization': f'Bearer {api_key}'}
                                    
                                    # Try person enrichment
                                    person_url = f"https://person.clearbit.com/v2/people/find?email=&name={quote(name)}"
                                    if company and company != "Unknown":
                                        person_url += f"&company={quote(company)}"
                                    
                                    person_response = requests.get(person_url, headers=headers, timeout=10)
                                    
                                    if person_response.status_code == 200:
                                        person_data = person_response.json()
                                        
                                        email = person_data.get('email')
                                        phone = None
                                        
                                        # Get phone from employment
                                        employment = person_data.get('employment', {})
                                        if employment:
                                            phone = employment.get('phone')
                                        
                                        if email or phone:
                                            return {
                                                'email': email,
                                                'phone': phone,
                                                'source': 'Clearbit Person API',
                                                'confidence': 'High',
                                                'url': person_data.get('linkedin', '')
                                            }
                                            
                                except Exception as e:
                                    st.warning(f"Clearbit API error: {str(e)}")
                                
                                return None

                            def simulate_search(name, company=None):
                                """Demo mode simulation"""
                                time.sleep(0.1)  # Simulate API delay
                                
                                if name and str(name) != "Unknown" and not pd.isna(name):
                                    name_str = str(name).lower().strip()
                                    name_parts = name_str.split()
                                    
                                    if len(name_parts) >= 2:
                                        formats = [
                                            f"{name_parts[0]}.{name_parts[-1]}@example.com",
                                            f"{name_parts[0][0]}{name_parts[-1]}@company.com",
                                            f"{name_parts[0]}_{name_parts[-1]}@business.net"
                                        ]
                                        email = np.random.choice(formats)
                                    else:
                                        email = f"{name_parts[0]}@example.com"
                                    
                                    phone = f"+1-{np.random.randint(200,999)}-{np.random.randint(100,999)}-{np.random.randint(1000,9999)}"
                                    
                                    return {
                                        'email': email,
                                        'phone': phone,
                                        'source': 'Demo Mode (Simulated)',
                                        'confidence': 'Medium',
                                        'url': 'https://example.com/demo'
                                    }
                                
                                return None

                            # Validation functions
                            def is_valid_email(email):
                                if pd.isna(email) or str(email).strip() == '':
                                    return False
                                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                                return bool(re.match(email_pattern, str(email).strip()))

                            def is_valid_phone(phone):
                                if pd.isna(phone) or str(phone).strip() == '':
                                    return False
                                clean_phone = re.sub(r'[^\d+]', '', str(phone))
                                return len(clean_phone) >= 10

                            # Main processing
                            results = []
                            progress_bar = st.progress(0)
                            status_text = st.empty()
                            
                            api_calls = 0
                            rate_limit_start = time.time()
                            
                            for idx in range(len(df)):
                                status_text.text(f"Processing row {idx + 1} of {len(df)}... (API calls: {api_calls})")
                                progress_bar.progress((idx + 1) / len(df))

                                row_data = {
                                    'Row': idx + 1,
                                    'Name': df[selected_name_col].iloc[idx] if selected_name_col != "None" else "Unknown",
                                    'Original Email': df[selected_email_col].iloc[idx] if selected_email_col != "None" else "",
                                    'Original Phone': df[selected_phone_col].iloc[idx] if selected_phone_col != "None" else "",
                                    'Company': df[selected_company_col].iloc[idx] if selected_company_col != "None" else "",
                                    'New Email': "",
                                    'New Phone': "",
                                    'Email Status': "",
                                    'Phone Status': "",
                                    'Search Source': "",
                                    'Confidence': "",
                                    'API Cost': "",
                                    'Notes': ""
                                }

                                # Check if email/phone needs filling
                                needs_email = not is_valid_email(row_data['Original Email'])
                                needs_phone = not is_valid_phone(row_data['Original Phone'])

                                if needs_email or needs_phone:
                                    # Rate limiting
                                    if api_calls >= max_requests:
                                        elapsed = time.time() - rate_limit_start
                                        if elapsed < 60:
                                            time.sleep(60 - elapsed)
                                        api_calls = 0
                                        rate_limit_start = time.time()
                                    
                                    # Perform search based on selected API
                                    if api_choice == "demo":
                                        search_result = simulate_search(row_data['Name'], row_data['Company'])
                                        cost = "$0.00"
                                    elif api_choice == "google":
                                        search_result = search_google(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            api_keys.get('google_api_key'), 
                                            api_keys.get('google_cx')
                                        )
                                        cost = "$0.005"
                                    elif api_choice == "hunter":
                                        search_result = search_hunter(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            api_keys.get('hunter_api_key')
                                        )
                                        cost = "0.01 credits"
                                    elif api_choice == "clearbit":
                                        search_result = search_clearbit(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            api_keys.get('clearbit_api_key')
                                        )
                                        cost = "$0.02"
                                    
                                    api_calls += 1

                                    if search_result:
                                        if needs_email and search_result.get('email'):
                                            row_data['New Email'] = search_result['email']
                                            row_data['Email Status'] = '‚úÖ Found'
                                            row_data['Notes'] += "Email found via API search. "
                                        elif needs_email:
                                            row_data['Email Status'] = '‚ùå Not Found'
                                            row_data['Notes'] += "Email not found in search results. "

                                        if needs_phone and search_result.get('phone'):
                                            row_data['New Phone'] = search_result['phone']
                                            row_data['Phone Status'] = '‚úÖ Found'
                                            row_data['Notes'] += "Phone found via API search. "
                                        elif needs_phone:
                                            row_data['Phone Status'] = '‚ùå Not Found'
                                            row_data['Notes'] += "Phone not found in search results. "

                                        row_data['Search Source'] = search_result['source']
                                        row_data['Confidence'] = search_result['confidence']
                                        row_data['API Cost'] = cost
                                    else:
                                        if needs_email:
                                            row_data['Email Status'] = '‚ùå Not Found'
                                            row_data['Notes'] += "No search results found. "
                                        if needs_phone:
                                            row_data['Phone Status'] = '‚ùå Not Found'
                                            row_data['Notes'] += "No search results found. "
                                        row_data['API Cost'] = cost
                                else:
                                    row_data['Email Status'] = '‚úì Already Valid'
                                    row_data['Phone Status'] = '‚úì Already Valid'
                                    row_data['Notes'] = 'No action needed - data already valid'
                                    row_data['API Cost'] = "$0.00"

                                results.append(row_data)

                            progress_bar.empty()
                            status_text.empty()

                            results_df = pd.DataFrame(results)

                            # Summary
                            st.subheader("üìä Auto-Fill Summary")
                            
                            total_rows = len(results)
                            emails_found = sum(1 for r in results if r['Email Status'] == '‚úÖ Found')
                            phones_found = sum(1 for r in results if r['Phone Status'] == '‚úÖ Found')
                            emails_not_found = sum(1 for r in results if r['Email Status'] == '‚ùå Not Found')
                            phones_not_found = sum(1 for r in results if r['Phone Status'] == '‚ùå Not Found')
                            already_valid = sum(1 for r in results if 'already valid' in r['Notes'].lower())
                            total_cost = sum(float(r['API Cost'].replace('$', '').replace(' credits', '')) 
                                           for r in results if r['API Cost'] and '$' in r['API Cost'])

                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Total Rows Processed", total_rows)
                                st.metric("Already Valid", already_valid)
                                st.metric("Total API Cost", f"${total_cost:.2f}")
                            with col2:
                                st.metric("Emails Found", emails_found)
                                st.metric("Emails Not Found", emails_not_found)
                            with col3:
                                st.metric("Phones Found", phones_found)
                                st.metric("Phones Not Found", phones_not_found)

                            # Show results
                            st.subheader("üìã Detailed Results")
                            st.dataframe(results_df, use_container_width=True)

                            # Create updated DataFrame
                            updated_df = df.copy()
                            if selected_email_col != "None":
                                for idx, row in results_df.iterrows():
                                    if row['New Email']:
                                        updated_df.at[idx, selected_email_col] = row['New Email']
                            
                            if selected_phone_col != "None":
                                for idx, row in results_df.iterrows():
                                    if row['New Phone']:
                                        updated_df.at[idx, selected_phone_col] = row['New Phone']

                            # Create Excel with multiple sheets
                            from io import BytesIO
                            import openpyxl
                            from openpyxl.styles import PatternFill, Font, Alignment

                            wb = openpyxl.Workbook()
                            
                            # Summary Sheet
                            ws_summary = wb.active
                            ws_summary.title = "Summary"
                            ws_summary['A1'] = "Auto-Fill Summary Report"
                            ws_summary['A1'].font = Font(bold=True, size=14)
                            ws_summary.merge_cells('A1:B1')
                            
                            ws_summary['A3'] = "Total Rows:"
                            ws_summary['B3'] = total_rows
                            ws_summary['A4'] = "Emails Found:"
                            ws_summary['B4'] = emails_found
                            ws_summary['A5'] = "Phones Found:"
                            ws_summary['B5'] = phones_found
                            ws_summary['A6'] = "Emails Not Found:"
                            ws_summary['B6'] = emails_not_found
                            ws_summary['A7'] = "Phones Not Found:"
                            ws_summary['B7'] = phones_not_found
                            ws_summary['A8'] = "Already Valid:"
                            ws_summary['B8'] = already_valid
                            ws_summary['A9'] = "Total API Cost:"
                            ws_summary['B9'] = f"${total_cost:.2f}"
                            
                            # Style summary
                            for row in range(3, 10):
                                ws_summary[f'A{row}'].font = Font(bold=True)

                            # Search Results Sheet
                            ws_results = wb.create_sheet("Search Results")
                            headers = list(results_df.columns)
                            for col_num, header in enumerate(headers, 1):
                                cell = ws_results.cell(row=1, column=col_num, value=header)
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
                                cell.font = Font(bold=True, color="FFFFFF")
                                cell.alignment = Alignment(horizontal="center")

                            for row_num, row_data in enumerate(results_df.values, 2):
                                for col_num, value in enumerate(row_data, 1):
                                    cell = ws_results.cell(row=row_num, column=col_num, value=str(value))
                                    
                                    # Color coding
                                    if '‚úÖ' in str(value):
                                        cell.fill = PatternFill(start_color="C8E6C9", end_color="C8E6C9", fill_type="solid")
                                    elif '‚ùå' in str(value):
                                        cell.fill = PatternFill(start_color="FFCDD2", end_color="FFCDD2", fill_type="solid")
                                    elif '‚úì' in str(value):
                                        cell.fill = PatternFill(start_color="E3F2FD", end_color="E3F2FD", fill_type="solid")

                            # Updated Data Sheet
                            ws_updated = wb.create_sheet("Updated Data")
                            headers = list(updated_df.columns)
                            for col_num, header in enumerate(headers, 1):
                                cell = ws_updated.cell(row=1, column=col_num, value=header)
                                cell.font = Font(bold=True)
                                cell.fill = PatternFill(start_color="70AD47", end_color="70AD47", fill_type="solid")
                                cell.font = Font(bold=True, color="FFFFFF")
                                cell.alignment = Alignment(horizontal="center")

                            for row_num, row_data in enumerate(updated_df.values, 2):
                                for col_num, value in enumerate(row_data, 1):
                                    ws_updated.cell(row=row_num, column=col_num, value=str(value))

                            # Auto-adjust column widths for all sheets
                            for ws in [ws_summary, ws_results, ws_updated]:
                                for column in ws.columns:
                                    max_length = 0
                                    column_letter = column[0].column_letter
                                    for cell in column:
                                        try:
                                            if cell.value and len(str(cell.value)) > max_length:
                                                max_length = len(str(cell.value))
                                        except:
                                            pass
                                    adjusted_width = min(max_length + 2, 50)
                                    ws.column_dimensions[column_letter].width = adjusted_width

                            # Save to BytesIO
                            excel_buffer = BytesIO()
                            wb.save(excel_buffer)
                            excel_buffer.seek(0)

                            # Download buttons
                            col1, col2 = st.columns(2)
                            with col1:
                                st.download_button(
                                    label="üì• Download Complete Report (Excel with 3 sheets)",
                                    data=excel_buffer,
                                    file_name="autofill_results.xlsx",
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                                    use_container_width=True
                                )
                            
                            with col2:
                                # Also offer CSV download of updated data
                                csv_updated = updated_df.to_csv(index=False)
                                st.download_button(
                                    label="üì• Download Updated Data (CSV)",
                                    data=csv_updated,
                                    file_name="updated_data.csv",
                                    mime="text/csv",
                                    use_container_width=True
                                )

                            st.success("‚úÖ Auto-fill process completed!")
                            st.info(f"""
                            **üìä Excel Report Contains 3 Sheets:**
                            1. **Summary** - Overview with cost breakdown
                            2. **Search Results** - Detailed findings with API sources
                            3. **Updated Data** - Your original data with filled information
                            
                            **üí∞ Total API Cost: ${total_cost:.2f}**
                            **üîç API Used: {selected_api}**
                            """)

                else:
                    st.warning("No relevant columns found. Please ensure your CSV has name, email, or phone columns.")
                    st.info(f"Available columns: {', '.join(df.columns.tolist())}")

            except Exception as e:
                st.error(f"Error in auto-fill process: {str(e)}")
                st.info("If you're using real APIs, please check your API keys and network connection.")
        else:
            st.info("Please upload a CSV file first to use the auto-fill feature.")

    elif st.session_state['feature'] == 'reach':
        st.header("üìà Increase Reach")

        # Lead finding logic - works with uploaded CSV or sample data
        if 'df' in st.session_state:
            try:
                # Use the DataFrame from session state
                df = st.session_state['df']

                # Check for relevant columns
                name_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['name', 'full_name', 'first_name', 'last_name', 'customer_name', 'person_name'])]
                email_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['email', 'mail', 'e-mail'])]
                phone_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['phone', 'mobile', 'tel', 'contact'])]
                company_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['company', 'organization', 'business', 'employer'])]
                location_cols = [col for col in df.columns if any(keyword in col.lower() for keyword in ['city', 'state', 'country', 'location', 'address', 'region', 'province', 'town', 'place'])]

                if name_cols or email_cols or phone_cols or company_cols or location_cols:
                    st.success("Ready to find leads!")
                    
                    # Configuration
                    st.subheader("‚öôÔ∏è Configuration")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        selected_name_col = st.selectbox("Name Column:", ["None"] + name_cols) if name_cols else "None"
                        selected_email_col = st.selectbox("Email Column:", ["None"] + email_cols) if email_cols else "None"
                        selected_company_col = st.selectbox("Company Column:", ["None"] + company_cols) if company_cols else "None"
                    
                    with col2:
                        selected_phone_col = st.selectbox("Phone Column:", ["None"] + phone_cols) if phone_cols else "None"
                        selected_location_col = st.selectbox("Location Column:", ["None"] + location_cols) if location_cols else "None"
                    
                    # Rate limiting and cost control
                    max_requests = st.slider("Max API Requests per Minute:", min_value=1, max_value=60, value=10)
                    st.warning(f"‚ö†Ô∏è This will make up to {len(df)} API calls. Estimated cost: ${len(df) * 0.005:.2f} (Google) or {len(df) * 0.01:.2f} credits (Hunter.io)")

                    if st.button("üîç Find Leads"):
                        with st.spinner("Finding leads..."):
                            import time
                            import requests
                            from urllib.parse import quote

                            # API Functions
                            def search_google(name, company=None, location=None, api_key=None, cx=None):
                                """Search Google Custom Search API for leads"""
                                if not api_key or not cx:
                                    return None
                                
                                try:
                                    query = f"{name}"
                                    if company and company != "Unknown":
                                        query += f" {company}"
                                    if location and location != "Unknown":
                                        query += f" {location}"
                                    query += " email phone contact"
                                    
                                    url = f"https://www.googleapis.com/customsearch/v1?key={api_key}&cx={cx}&q={quote(query)}&num=5"
                                    response = requests.get(url, timeout=10)
                                    
                                    if response.status_code == 200:
                                        data = response.json()
                                        email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
                                        phone_pattern = r'\+?1?\d{10,15}'
                                        
                                        emails = []
                                        phones = []
                                        
                                        for item in data.get('items', [])[:3]:
                                            snippet = item.get('snippet', '')
                                            title = item.get('title', '')
                                            content = snippet + " " + title
                                            
                                            emails.extend(re.findall(email_pattern, content))
                                            phones.extend(re.findall(phone_pattern, content))
                                        
                                        if emails or phones:
                                            return {
                                                'email': emails[0] if emails else None,
                                                'phone': phones[0] if phones else None,
                                                'source': 'Google Custom Search',
                                                'confidence': 'Medium',
                                                'url': data.get('items', [{}])[0].get('link', '') if data.get('items') else ''
                                            }
                                except Exception as e:
                                    st.warning(f"Google API error: {str(e)}")
                                
                                return None

                            def search_hunter(name, company=None, location=None, api_key=None):
                                """Search Hunter.io API for leads"""
                                if not api_key:
                                    return None
                                
                                try:
                                    # Try domain search first if company is available
                                    if company and company != "Unknown":
                                        domain_url = f"https://api.hunter.io/v2/domain-search?domain={quote(company)}&api_key={api_key}"
                                        domain_response = requests.get(domain_url, timeout=10)
                                        
                                        if domain_response.status_code == 200:
                                            domain_data = domain_response.json()
                                            emails = domain_data.get('data', {}).get('emails', [])
                                            if emails:
                                                # Find email that matches name
                                                name_parts = str(name).lower().split()
                                                for email_data in emails[:5]:
                                                    email = email_data.get('value', '')
                                                    if name_parts and name_parts[0] in email.lower():
                                                        return {
                                                            'email': email,
                                                            'phone': None,
                                                            'source': 'Hunter.io Domain Search',
                                                            'confidence': 'High',
                                                            'url': f"https://hunter.io/search/{company}"
                                                        }
                                    
                                    # Fallback to email finder
                                    if '@' not in str(name):
                                        finder_url = f"https://api.hunter.io/v2/email-finder?full_name={quote(name)}&api_key={api_key}"
                                        if company and company != "Unknown":
                                            finder_url += f"&company={quote(company)}"
                                        
                                        finder_response = requests.get(finder_url, timeout=10)
                                        
                                        if finder_response.status_code == 200:
                                            finder_data = finder_response.json()
                                            email = finder_data.get('data', {}).get('email')
                                            if email:
                                                return {
                                                    'email': email,
                                                    'phone': None,
                                                    'source': 'Hunter.io Email Finder',
                                                    'confidence': 'High',
                                                    'url': f"https://hunter.io/verify/{email}"
                                                }
                                                
                                except Exception as e:
                                    st.warning(f"Hunter.io API error: {str(e)}")
                                
                                return None

                            def search_clearbit(name, company=None, location=None, api_key=None):
                                """Search Clearbit API for leads"""
                                if not api_key:
                                    return None
                                
                                try:
                                    headers = {'Authorization': f'Bearer {api_key}'}
                                    
                                    # Try person enrichment
                                    person_url = f"https://person.clearbit.com/v2/people/find?email=&name={quote(name)}"
                                    if company and company != "Unknown":
                                        person_url += f"&company={quote(company)}"
                                    
                                    person_response = requests.get(person_url, headers=headers, timeout=10)
                                    
                                    if person_response.status_code == 200:
                                        person_data = person_response.json()
                                        
                                        email = person_data.get('email')
                                        phone = None
                                        
                                        # Get phone from employment
                                        employment = person_data.get('employment', {})
                                        if employment:
                                            phone = employment.get('phone')
                                        
                                        if email or phone:
                                            return {
                                                'email': email,
                                                'phone': phone,
                                                'source': 'Clearbit Person API',
                                                'confidence': 'High',
                                                'url': person_data.get('linkedin', '')
                                            }
                                            
                                except Exception as e:
                                    st.warning(f"Clearbit API error: {str(e)}")
                                
                                return None

                            def simulate_search(name, company=None, location=None):
                                """Demo mode simulation for leads"""
                                time.sleep(0.1)  # Simulate API delay
                                
                                if name and str(name) != "Unknown" and not pd.isna(name):
                                    name_str = str(name).lower().strip()
                                    name_parts = name_str.split()
                                    
                                    if len(name_parts) >= 2:
                                        formats = [
                                            f"{name_parts[0]}.{name_parts[-1]}@example.com",
                                            f"{name_parts[0][0]}{name_parts[-1]}@company.com",
                                            f"{name_parts[0]}_{name_parts[-1]}@business.net"
                                        ]
                                        email = np.random.choice(formats)
                                    else:
                                        email = f"{name_parts[0]}@example.com"
                                    
                                    phone = f"+1-{np.random.randint(200,999)}-{np.random.randint(100,999)}-{np.random.randint(1000,9999)}"
                                    
                                    return {
                                        'email': email,
                                        'phone': phone,
                                        'source': 'Demo Mode (Simulated)',
                                        'confidence': 'Medium',
                                        'url': 'https://example.com/demo'
                                    }
                                
                                return None

                            # Validation functions
                            def is_valid_email(email):
                                if pd.isna(email) or str(email).strip() == '':
                                    return False
                                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                                return bool(re.match(email_pattern, str(email).strip()))

                            def is_valid_phone(phone):
                                if pd.isna(phone) or str(phone).strip() == '':
                                    return False
                                clean_phone = re.sub(r'[^\d+]', '', str(phone))
                                return len(clean_phone) >= 10

                            # Main processing
                            results = []
                            progress_bar = st.progress(0)
                            status_text = st.empty()
                            
                            api_calls = 0
                            rate_limit_start = time.time()
                            
                            for idx in range(len(df)):
                                status_text.text(f"Processing row {idx + 1} of {len(df)}... (API calls: {api_calls})")
                                progress_bar.progress((idx + 1) / len(df))

                                row_data = {
                                    'Row': idx + 1,
                                    'Name': df[selected_name_col].iloc[idx] if selected_name_col != "None" else "Unknown",
                                    'Original Email': df[selected_email_col].iloc[idx] if selected_email_col != "None" else "",
                                    'Original Phone': df[selected_phone_col].iloc[idx] if selected_phone_col != "None" else "",
                                    'Company': df[selected_company_col].iloc[idx] if selected_company_col != "None" else "",
                                    'Location': df[selected_location_col].iloc[idx] if selected_location_col != "None" else "",
                                    'New Email': "",
                                    'New Phone': "",
                                    'Email Status': "",
                                    'Phone Status': "",
                                    'Search Source': "",
                                    'Confidence': "",
                                    'API Cost': "",
                                    'Notes': ""
                                }

                                # Check if email/phone needs filling
                                needs_email = not is_valid_email(row_data['Original Email'])
                                needs_phone = not is_valid_phone(row_data['Original Phone'])

                                if needs_email or needs_phone:
                                    # Rate limiting
                                    if api_calls >= max_requests:
                                        elapsed = time.time() - rate_limit_start
                                        if elapsed < 60:
                                            time.sleep(60 - elapsed)
                                        api_calls = 0
                                        rate_limit_start = time.time()
                                    
                                    # Perform search based on selected API
                                    if api_choice == "demo":
                                        search_result = simulate_search(row_data['Name'], row_data['Company'], row_data['Location'])
                                        cost = "$0.00"
                                    elif api_choice == "google":
                                        search_result = search_google(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            row_data['Location'],
                                            api_keys.get('google_api_key'), 
                                            api_keys.get('google_cx')
                                        )
                                        cost = "$0.005"
                                    elif api_choice == "hunter":
                                        search_result = search_hunter(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            row_data['Location'],
                                            api_keys.get('hunter_api_key')
                                        )
                                        cost = "0.01 credits"
                                    elif api_choice == "clearbit":
                                        search_result = search_clearbit(
                                            row_data['Name'], 
                                            row_data['Company'], 
                                            row_data['Location'],
                                            api_keys.get('clearbit_api
